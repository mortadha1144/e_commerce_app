// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'network_exceptions.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$NetworkExceptions implements DiagnosticableTreeMixin {
  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    properties..add(DiagnosticsProperty('type', 'NetworkExceptions'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is NetworkExceptions);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'NetworkExceptions()';
  }
}

/// @nodoc
class $NetworkExceptionsCopyWith<$Res> {
  $NetworkExceptionsCopyWith(
      NetworkExceptions _, $Res Function(NetworkExceptions) __);
}

/// @nodoc

class EmailAlreadyInUse
    with DiagnosticableTreeMixin
    implements NetworkExceptions {
  const EmailAlreadyInUse();

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    properties
      ..add(DiagnosticsProperty('type', 'NetworkExceptions.emailAlreadyInUse'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is EmailAlreadyInUse);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'NetworkExceptions.emailAlreadyInUse()';
  }
}

/// @nodoc
class $EmailAlreadyInUseCopyWith<$Res>
    implements $NetworkExceptionsCopyWith<$Res> {
  $EmailAlreadyInUseCopyWith(
      EmailAlreadyInUse _, $Res Function(EmailAlreadyInUse) __);
}

/// @nodoc
class _$EmailAlreadyInUseCopyWithImpl<$Res>
    implements $EmailAlreadyInUseCopyWith<$Res> {
  _$EmailAlreadyInUseCopyWithImpl(this._self, this._then);

  final EmailAlreadyInUse _self;
  final $Res Function(EmailAlreadyInUse) _then;
}

/// @nodoc

class WrongPassword with DiagnosticableTreeMixin implements NetworkExceptions {
  const WrongPassword();

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    properties
      ..add(DiagnosticsProperty('type', 'NetworkExceptions.wrongPassword'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is WrongPassword);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'NetworkExceptions.wrongPassword()';
  }
}

/// @nodoc
class $WrongPasswordCopyWith<$Res> implements $NetworkExceptionsCopyWith<$Res> {
  $WrongPasswordCopyWith(WrongPassword _, $Res Function(WrongPassword) __);
}

/// @nodoc
class _$WrongPasswordCopyWithImpl<$Res>
    implements $WrongPasswordCopyWith<$Res> {
  _$WrongPasswordCopyWithImpl(this._self, this._then);

  final WrongPassword _self;
  final $Res Function(WrongPassword) _then;
}

/// @nodoc

class InvalidEmail with DiagnosticableTreeMixin implements NetworkExceptions {
  const InvalidEmail();

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    properties
      ..add(DiagnosticsProperty('type', 'NetworkExceptions.invalidEmail'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is InvalidEmail);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'NetworkExceptions.invalidEmail()';
  }
}

/// @nodoc
class $InvalidEmailCopyWith<$Res> implements $NetworkExceptionsCopyWith<$Res> {
  $InvalidEmailCopyWith(InvalidEmail _, $Res Function(InvalidEmail) __);
}

/// @nodoc
class _$InvalidEmailCopyWithImpl<$Res> implements $InvalidEmailCopyWith<$Res> {
  _$InvalidEmailCopyWithImpl(this._self, this._then);

  final InvalidEmail _self;
  final $Res Function(InvalidEmail) _then;
}

/// @nodoc

class OperationNotAllowed
    with DiagnosticableTreeMixin
    implements NetworkExceptions {
  const OperationNotAllowed();

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    properties
      ..add(
          DiagnosticsProperty('type', 'NetworkExceptions.operationNotAllowed'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is OperationNotAllowed);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'NetworkExceptions.operationNotAllowed()';
  }
}

/// @nodoc
class $OperationNotAllowedCopyWith<$Res>
    implements $NetworkExceptionsCopyWith<$Res> {
  $OperationNotAllowedCopyWith(
      OperationNotAllowed _, $Res Function(OperationNotAllowed) __);
}

/// @nodoc
class _$OperationNotAllowedCopyWithImpl<$Res>
    implements $OperationNotAllowedCopyWith<$Res> {
  _$OperationNotAllowedCopyWithImpl(this._self, this._then);

  final OperationNotAllowed _self;
  final $Res Function(OperationNotAllowed) _then;
}

/// @nodoc

class WeakPassword with DiagnosticableTreeMixin implements NetworkExceptions {
  const WeakPassword();

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    properties
      ..add(DiagnosticsProperty('type', 'NetworkExceptions.weakPassword'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is WeakPassword);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'NetworkExceptions.weakPassword()';
  }
}

/// @nodoc
class $WeakPasswordCopyWith<$Res> implements $NetworkExceptionsCopyWith<$Res> {
  $WeakPasswordCopyWith(WeakPassword _, $Res Function(WeakPassword) __);
}

/// @nodoc
class _$WeakPasswordCopyWithImpl<$Res> implements $WeakPasswordCopyWith<$Res> {
  _$WeakPasswordCopyWithImpl(this._self, this._then);

  final WeakPassword _self;
  final $Res Function(WeakPassword) _then;
}

/// @nodoc

class UserDisabled with DiagnosticableTreeMixin implements NetworkExceptions {
  const UserDisabled();

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    properties
      ..add(DiagnosticsProperty('type', 'NetworkExceptions.userDisabled'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is UserDisabled);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'NetworkExceptions.userDisabled()';
  }
}

/// @nodoc
class $UserDisabledCopyWith<$Res> implements $NetworkExceptionsCopyWith<$Res> {
  $UserDisabledCopyWith(UserDisabled _, $Res Function(UserDisabled) __);
}

/// @nodoc
class _$UserDisabledCopyWithImpl<$Res> implements $UserDisabledCopyWith<$Res> {
  _$UserDisabledCopyWithImpl(this._self, this._then);

  final UserDisabled _self;
  final $Res Function(UserDisabled) _then;
}

/// @nodoc

class UserNotFound with DiagnosticableTreeMixin implements NetworkExceptions {
  const UserNotFound();

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    properties
      ..add(DiagnosticsProperty('type', 'NetworkExceptions.userNotFound'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is UserNotFound);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'NetworkExceptions.userNotFound()';
  }
}

/// @nodoc
class $UserNotFoundCopyWith<$Res> implements $NetworkExceptionsCopyWith<$Res> {
  $UserNotFoundCopyWith(UserNotFound _, $Res Function(UserNotFound) __);
}

/// @nodoc
class _$UserNotFoundCopyWithImpl<$Res> implements $UserNotFoundCopyWith<$Res> {
  _$UserNotFoundCopyWithImpl(this._self, this._then);

  final UserNotFound _self;
  final $Res Function(UserNotFound) _then;
}

/// @nodoc

class AuthInvalidEmail
    with DiagnosticableTreeMixin
    implements NetworkExceptions {
  const AuthInvalidEmail();

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    properties
      ..add(DiagnosticsProperty('type', 'NetworkExceptions.authInvalidEmail'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is AuthInvalidEmail);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'NetworkExceptions.authInvalidEmail()';
  }
}

/// @nodoc
class $AuthInvalidEmailCopyWith<$Res>
    implements $NetworkExceptionsCopyWith<$Res> {
  $AuthInvalidEmailCopyWith(
      AuthInvalidEmail _, $Res Function(AuthInvalidEmail) __);
}

/// @nodoc
class _$AuthInvalidEmailCopyWithImpl<$Res>
    implements $AuthInvalidEmailCopyWith<$Res> {
  _$AuthInvalidEmailCopyWithImpl(this._self, this._then);

  final AuthInvalidEmail _self;
  final $Res Function(AuthInvalidEmail) _then;
}

/// @nodoc

class AuthUserNotFound
    with DiagnosticableTreeMixin
    implements NetworkExceptions {
  const AuthUserNotFound();

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    properties
      ..add(DiagnosticsProperty('type', 'NetworkExceptions.authUserNotFound'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is AuthUserNotFound);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'NetworkExceptions.authUserNotFound()';
  }
}

/// @nodoc
class $AuthUserNotFoundCopyWith<$Res>
    implements $NetworkExceptionsCopyWith<$Res> {
  $AuthUserNotFoundCopyWith(
      AuthUserNotFound _, $Res Function(AuthUserNotFound) __);
}

/// @nodoc
class _$AuthUserNotFoundCopyWithImpl<$Res>
    implements $AuthUserNotFoundCopyWith<$Res> {
  _$AuthUserNotFoundCopyWithImpl(this._self, this._then);

  final AuthUserNotFound _self;
  final $Res Function(AuthUserNotFound) _then;
}

/// @nodoc

class UnexpectedError
    with DiagnosticableTreeMixin
    implements NetworkExceptions {
  const UnexpectedError();

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    properties
      ..add(DiagnosticsProperty('type', 'NetworkExceptions.unexpectedError'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is UnexpectedError);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'NetworkExceptions.unexpectedError()';
  }
}

/// @nodoc
class $UnexpectedErrorCopyWith<$Res>
    implements $NetworkExceptionsCopyWith<$Res> {
  $UnexpectedErrorCopyWith(
      UnexpectedError _, $Res Function(UnexpectedError) __);
}

/// @nodoc
class _$UnexpectedErrorCopyWithImpl<$Res>
    implements $UnexpectedErrorCopyWith<$Res> {
  _$UnexpectedErrorCopyWithImpl(this._self, this._then);

  final UnexpectedError _self;
  final $Res Function(UnexpectedError) _then;
}

// dart format on
